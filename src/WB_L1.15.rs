// Задача
// Реализовать быструю сортировку массива (quicksort) встроенными методами языка.

fn partition(arr: &mut [i32]) -> usize{
    // Опорным элементом выбираем последний элемент массива
    let pivot = arr.len() - 1;
    // Индекс для отслеживания границы меньших элементов
    let mut x = 0;
    // Проходим по всем элементам, кроме последнего (опорного)
    for i in 0..pivot{
        // Если элемент меньше опорного, меняем его местами с элементом на позиции i
        if arr[i] < arr[pivot]{
            arr.swap(x, i);
            x += 1;
        }
    }
    // Перемещаем опорный элемент на правильное место (между меньшими и большими элементами)
    arr.swap(x, pivot);
    // Возвращаем индекс, на который был перемещен опорный элемент
    x
}

fn quicksort(arr: &mut [i32]) {
    // Базовый случай: если длина массива меньше или равна 1, он уже отсортирован
    if arr.len() <= 1 {
        return;
    }
    // Выполняем разбиение массива и получаем индекс опорного элемента
    let pivot_index = partition(arr);
    // Разделяем массив на две части: левую (меньше pivot) и правую (больше pivot)
    let (left, right) = arr.split_at_mut(pivot_index);
    // Рекурсивно сортируем левую часть
    quicksort(left);
    // Рекурсивно сортируем правую часть, исключая сам pivot (поэтому используем &mut right[1..])
    quicksort(&mut right[1..]);
}
fn main() {
    // Исходный массив для сортировки
    let mut arr = [34, 7, 23, 32, 5, 62];
    // Вызываем функцию быстрой сортировки для массива
    quicksort(&mut arr);
    // Выводим отсортированный массив
    println!("{:?}", arr);
}
